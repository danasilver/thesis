\chapter{Background}

\section{State of the Art}
  \begin{enumerate}
    \item Tools that currently exist and inspired MiddGuard.
    \begin{enumerate}
      \item Improvise
      \item Eagle Eyes
    \end{enumerate}
  \end{enumerate}

\section{Previous Work on MiddGuard}
\subsection{VAST 2014}

Initial work on the MiddGuard framework began during summer 2014 as a research
project conducted by Christopher Andrews and Dana Silver. For a VAST 2014 Mini-Challenge
2 \cite{vast2014mc2} submission, we created a web interface to
visualize and analyze data from the challenge scenario. Data were preprocessed
using several disjoint Python scripts and the resulting manipulations were
persisted to a SQLite database. On the back-end of the web service, a simple
RESTful Python web server implemented with Flask \cite{flask} and Flask RESTful
\cite{flask-restful} queried the database and transformed data for various
front-end visualizations. The server also performed manipulations in addition
those in the preprocessing stage on a request-by-request basis based on analyst
input in the interactive visualizations.

An example of the flow between preprocessing scripts, back-end server, and
front-end visualization is how we identified points of interest in the
Mini-Challenge 2 geographical data. The VAST 2014 Challenge \cite{vast2014}
posited the following fictitous scenario:

\begin{quote}

In January, 2014, the leaders of GAStech are celebrating their new-found fortune
as a result of the initial public offering of their very successful company. In
the midst of this celebration, several employees of GAStech go missing. An
organization known as the Protectors of Kronos (POK) is suspected in the
disappearance, but things may not be what they seem.

\end{quote}

Available data for Mini-Challenge 2 included vehicle tracking data from
company cars, an ESRI shapefile of the island where GAStech is located, and an
illustrated tourist map of the island. Tracking data contained lists of
latitude, longitude, timestamp, and car ID. A preprocessing script iterated
through each trace's points, identified periods where a car was stopped for
greater than 120 seconds, and saved that coordinate as a destination for the
associated car. A visualization used TopoJSON \cite{topojson-spec} generated
from the shapefile and the tracking data to draw a map of the city overlayed
with cars' movements and destinations. By selecting a destination in the
visualization, an investigator could create a point of interest based on the
names of locations in the tourist map and persist the association of point of
interest and destination to the database. During the persistence step other
destinations within a certain radius would also be associate with that point of
interest.

The VAST 2014 submission was unsuccessful. Working on the tool described above
took most of the available time and investigators were not left with sufficient
time to complete the investigation and write up the results.

The first version of MiddGuard, which was developed in response to summer
research at Middlebury, attempted to generalize parts of the web server and
front-end that could be reused throughout multiple investigations, while keeping
the framework unopinionated with respect to the data it could handle. The
framework's primary features were automatic persistence to a database, data
transport between the server and connected web clients in real-time, centralized
data storage in the web browser, and visualization module loading/unloading in
the browser.

This version of MiddGuard achieved flexibility by automatically loading three
types of customizable packages. These were referred to as analytics, modules,
and models. Analytics were scripts that could be triggered by a remote procedure
call from a front-end visualization. They could be passed data from the
front-end. Using the VAST 2014 example, they were meant to handle computations
like finding other destinations near a point of interest.

Modules were front-end visualizations. JavaScript and CSS files required for the
visualization were declared in a package's \texttt{manifest.json} file. The
database was accessible on the front-end, with each table represented by a
Backbone.js collection. Modules could access collections using the global
\texttt{middguard.entities} object. Collections were updated in real-time over
WebSockets, so by listening to changes in a collection or the models it
contained, a visualization could update in real-time based on changing data on
the server. By extending a base MiddGuard View \cite{backbone} and registering
with MiddGuard by calling a function \texttt{middguard.module(name,
constructor)}, visualizations could be loaded and unloaded from the window with
a button click from MiddGuard's sidebar.

Models were the final piece of customization, intended to give the database
flexible schema to work with any data. Models were a combination of database
migrations and a Bookshelf.js \cite{bookshelf} model declaration. MiddGuard
included a \texttt{migrate} command to migrate models on a table-by-table basis,
applying the results a single database. The model declarations were patched to
emit WebSocket events on create, read, update, and delete events so that
analytics packages could be written to use the models, persist changes, and
communicate those changes to connected clients without needing to explicitly
alert connected clients. Relationships could be established between models using
a special \texttt{relationship} table that stored pairs of table names and row
ids.

\subsection{View Reference Counting}

\begin{enumerate}
  \item MiddGuard Version 1 (Summer 2014)
  \begin{enumerate}
    \item Reusable components
    \item Award/VAST 2015 challenge
  \end{enumerate}
\end{enumerate}
